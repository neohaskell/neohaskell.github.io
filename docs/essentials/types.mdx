---
sidebar_position: 4
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Badge from "@site/src/components/Badge";
import Figure from "@site/src/components/Figure";

# Types

:::caution
The documentation that you're reading is a design document where most of
the features you're reading are yet to be implemented. Check the [Note on the Docs](/docs/docs-intro)
:::

One of the key features of NeoHaskell is its type system. Some people have preconceived
ideas about types, and they think that they get in the way of development process too
much. This is usually because either the type system of the programming language they
are using is not flexible enough, or that types come as an afterthought of the 
development process of their system, like if it is a "necessary bad thing".

In NeoHaskell, types become your best friends. Not only because NeoHaskell's type 
system is quite different to type systems from other programming languages (e.g. 
it doesn't support inheritance, but supports _super-generics_) but also because
it becomes a very useful design tool for your software development toolbox.

With the NeoHaskell type system, you can sketch an outline of your system, that then
you can fill with the colors of an implementation. If your sketch outlines a dog,
you might color it better or worse, but it will still be a dog.

## Primitive types

In NeoHaskell, you've got the typical primitive types out of the box:

| Type | Description |
|-----|---------|
| Int | For storing integer numbers between .....|
| BigInt | For storing integer numbers between .....|
| Float | For storing decimal numbers between ...|
| Double | For storing decimal numbers between ...|
| Bool | For storing either True or False |
| Char | For storing single characters |

Of course there are much more many types, but you can consider these as the 
most basic ones.

## Annotating Constants

Until now, when we wanted to create a constant, we just assigned a value to a name.
In the NeoHaskell repl, we could do it like so:

```haskell
neo> myConstant = 42
```

In this case, the compiler will automatically _infer_ that the type of `myConstant`
is `Int`. But it could be possible that we want it to be of type `BigInt`, instead of 
`Int`.

Given that types are a powerful tool for designing our programs, in NeoHaskell they 
get to be on their own line. This means, that for annotating the type of a constant,
we write the type on a line above the assignment line.

We write the type of a constant by using the `::` symbol, which reads as "is of type".

```haskell
myConstant :: BigInt
myConstant = 42
```

:::tip
In the NeoHaskell REPL, use the command `:{` to begin writing multiple lines,
use the command `:}` to end the multi-line input.
:::

If we wanted to try this on the REPL, we could do it like so:

```haskell
neo> :{
  myConstant :: BigInt
  myConstant = 42
  :}

neo> myConstant
42
```

## Checking the type of something

In the NeoHaskell REPL, you have a pretty useful command to check the type of stuff,
you can write `:type` and the name of something, and it will tell you the type:

```haskell
neo> :type myConstant
myConstant :: BigInt
```

It replies with "myConstant is of type BigInt".

## Avoiding primitive obsession

There's this concept in software development called "primitive obsession" which
essentially says that using primitive types for everything is bad.

This is because they don't really tell you a story about how your program is 
structured, or how your data gets transformed.

A counter-argument that people usually say against "wrapper types", or types whose
only reason of life is to give a name to a primitive type, is that they are not 
very efficient. You now would need to have both the primitive value in memory, and 
the wrapper that gives the type a name.

In NeoHaskell, you get to create these wrapper types for free.

In memory, it is only stored the actual value of the primitive type, but in compilation,
the compiler thinks that it is a different type.

To create a type of this kind, you use the `newtype` keyword and do it this way:

```haskell
newtype Age = Age Int
```

This creates a new type called `Age` whose sole purpose is to be differentiated from 
other `Int`s.

To create a constant with this type, you use it's name before the actual `Int` value:

```haskell
neo> catAge = Age 2
```

Note how now, you cannot use it as another Int 

```haskell
neo> catAge + 4
error: Attempting to use operator `+` on Age and Int, they do not match...
```

