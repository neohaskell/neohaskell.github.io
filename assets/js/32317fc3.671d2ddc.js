"use strict";(self.webpackChunkneohaskell_github_io=self.webpackChunkneohaskell_github_io||[]).push([[9938],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=p(a),h=r,u=m["".concat(s,".").concat(h)]||m[h]||c[h]||i;return a?n.createElement(u,l(l({ref:t},d),{},{components:a})):n.createElement(u,l({ref:t},d))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},165:(e,t,a)=>{a.d(t,{Z:()=>r});var n=a(7294);const r=e=>{let{issue:t,absolute:a}=e;const[r,i]=n.useState("loading"),[l,o]=n.useState();(0,n.useEffect)((()=>{try{fetch(`https://api.github.com/repos/neohaskell/neohaskell/issues/${t}`).then((e=>e.json())).then((e=>{e&&(i(e.state),o(e.title))}))}catch(e){console.error(e)}}),[]);const s=r?`NOT IMPLEMENTED YET: #${t} - ${l}`:"LOADING",p=`tooltip ${a?"absolute z-10 p-4":""}`;return n.createElement("a",{className:p,"data-tip":s,target:"_blank",href:`https://github.com/neohaskell/neohaskell/issues/${t}`},n.createElement("div",{className:`badge border-black ${{open:"badge-warning",closed:"hidden",loading:"badge-primary"}[r]} badge-lg`}))}},1645:(e,t,a)=>{a.d(t,{Z:()=>r});var n=a(7294);function r(e){let{src:t,sourceLink:a,alt:r}=e;return n.createElement("figure",{className:"!flex !flex-col !place-items-center"},n.createElement("img",{src:t,alt:r}),n.createElement("figcaption",{className:"!text-xs"},`Source: ${a}`))}},660:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>p,toc:()=>m});var n=a(7462),r=(a(7294),a(3905)),i=a(165),l=a(1645);const o={sidebar_position:0},s="Doing Math",p={unversionedId:"essentials/math",id:"essentials/math",title:"Doing Math",description:"The documentation that you're reading is a design document where most of",source:"@site/docs/essentials/math.mdx",sourceDirName:"essentials",slug:"/essentials/math",permalink:"/docs/essentials/math",draft:!1,editUrl:"https://github.com/neohaskell/neohaskell.github.io/tree/main/docs/essentials/math.mdx",tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0},sidebar:"tutorialSidebar",previous:{title:"Playing with the REPL",permalink:"/docs/getting-started/interactive-console"},next:{title:"Constants",permalink:"/docs/essentials/constants"}},d={},m=[{value:'Basic Math <Badge issue="22"/>',id:"basic-math-",level:2},{value:"Trying it in the REPL",id:"trying-it-in-the-repl",level:2},{value:"Addition Example",id:"addition-example",level:3},{value:"Subtraction Example",id:"subtraction-example",level:3},{value:"Division Example",id:"division-example",level:3},{value:"Power Example",id:"power-example",level:3},{value:"Remainder Example",id:"remainder-example",level:3},{value:"Right Shift Example",id:"right-shift-example",level:3},{value:"Left Shift Example",id:"left-shift-example",level:3},{value:"Spacing doesn&#39;t matter",id:"spacing-doesnt-matter",level:3},{value:"More Advanced Math",id:"more-advanced-math",level:2}],c={toc:m},h="wrapper";function u(e){let{components:t,...o}=e;return(0,r.kt)(h,(0,n.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"doing-math"},"Doing Math"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The documentation that you're reading is a design document where most of\nthe features you're reading are yet to be implemented. Check the ",(0,r.kt)("a",{parentName:"p",href:"/docs/docs-intro"},"Note on the Docs"))),(0,r.kt)("p",null,"As the Professor Walter White said once, \"Jesse, let's cook some math\", or something like that, I don't know."),(0,r.kt)("p",null,"Anyways, let's get to the point."),(0,r.kt)("h2",{id:"basic-math-"},"Basic Math ",(0,r.kt)(i.Z,{issue:"22",mdxType:"Badge"})),(0,r.kt)("p",null,"Here's a table of the typical math operators in NeoHaskell and what they do:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operator"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"+")),(0,r.kt)("td",{parentName:"tr",align:null},"Adds two numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-")),(0,r.kt)("td",{parentName:"tr",align:null},"Subtracts two numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*")),(0,r.kt)("td",{parentName:"tr",align:null},"Multiplies two numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"/")),(0,r.kt)("td",{parentName:"tr",align:null},"Divides two numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"**")),(0,r.kt)("td",{parentName:"tr",align:null},"Raises a number to a power")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"%")),(0,r.kt)("td",{parentName:"tr",align:null},"Gets the remainder of a division")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},">>")),(0,r.kt)("td",{parentName:"tr",align:null},"Shift right binary operation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<<")),(0,r.kt)("td",{parentName:"tr",align:null},"Shift left binary operation")))),(0,r.kt)("h2",{id:"trying-it-in-the-repl"},"Trying it in the REPL"),(0,r.kt)("h3",{id:"addition-example"},"Addition Example"),(0,r.kt)("p",null,"Lets say that I want to add 56 and 72 and find its result, I can do it as shown:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 56+72\n128\n")),(0,r.kt)("h3",{id:"subtraction-example"},"Subtraction Example"),(0,r.kt)("p",null,"In this example I am subtracting 64 from 112"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 112-64\n48\n")),(0,r.kt)("h3",{id:"division-example"},"Division Example"),(0,r.kt)("p",null,"Lets say I want to divide 117 by 12 and find the quotient, I can do it in NeoHaskell like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 117/12\n9\n")),(0,r.kt)("h3",{id:"power-example"},"Power Example"),(0,r.kt)("p",null,"Lets say I want to find what we will get by cubing five (five raised to the power of three), I can do it in NeoHaskell as shown:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 5**3\n125\n")),(0,r.kt)("h3",{id:"remainder-example"},"Remainder Example"),(0,r.kt)("p",null,"I want to know what we will get as remainder when we divide -21 by 4, I can do it as shown:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> -21%4\n-1\n")),(0,r.kt)("h3",{id:"right-shift-example"},"Right Shift Example"),(0,r.kt)("p",null,"This operator shifts the bits (the 1's and 0's of the computer representation) of a number to the right by a specified number of bits. For example, if we shift the bits of 5 to the right by 2 bits, we will get 1. This is because 5 in binary is 101, and when we shift it to the right by 2 bits, we get 1, which is 001 in binary."),(0,r.kt)(l.Z,{src:a(5849).Z,alt:"Graphical explanation of the above",sourceLink:"https://www.geeksforgeeks.org/left-shift-right-shift-operators-c-cpp/",mdxType:"Figure"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 5>>2\n1\n")),(0,r.kt)("h3",{id:"left-shift-example"},"Left Shift Example"),(0,r.kt)("p",null,"This operator shifts the bits (the 1's and 0's of the computer representation) of a number to the left by a specified number of bits. For example, if we shift the bits of 5 to the left by 2 bits, we will get 20. This is because 5 in binary is 101, and when we shift it to the left by 2 bits, we get 20, which is 10100 in binary."),(0,r.kt)(l.Z,{src:a(7081).Z,alt:"Graphical explanation of the above",sourceLink:"https://www.geeksforgeeks.org/left-shift-right-shift-operators-c-cpp/",mdxType:"Figure"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 5<<2\n20\n")),(0,r.kt)("h3",{id:"spacing-doesnt-matter"},"Spacing doesn't matter"),(0,r.kt)("p",null,"NeoHaskell doesn't care about spacing, you can write the above examples as shown below and it will still work:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 56 + 72\n128\n\nneo> 112         - 64\n48\n\nneo> 117 /              12\n9\n\nneo> 5 **3\n125\n")),(0,r.kt)("h2",{id:"more-advanced-math"},"More Advanced Math"),(0,r.kt)("p",null,"More advanced math functions are available in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Math")," module. It is\navailable by default, so you don't need to import it."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Modules? Import? What??")),(0,r.kt)("p",null,"Don't worry, we'll get to that later. For now, just know that you can use\ndo some math operations like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> Math.sin 90\n0.8939966636005579\n\nneo> Math.sqrt 64\n8\n\nneo> Math.log 10\n2.302585092994046\n")),(0,r.kt)("p",null,"You can experiment and explore the advanced math functions available by\ntyping ",(0,r.kt)("inlineCode",{parentName:"p"},"Math.")," and then pressing ",(0,r.kt)("inlineCode",{parentName:"p"},"TAB")," to see the list of functions."))}u.isMDXComponent=!0},7081:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Bitwise-operator-left-shift-c49e117130a90a876cb1fa8b6af554a0.png"},5849:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Bitwise-operator-right-shift-72fdaa1bf9862e45afeb60ce2ebdac7e.png"}}]);