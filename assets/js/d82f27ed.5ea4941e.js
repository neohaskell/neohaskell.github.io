"use strict";(self.webpackChunkneohaskell_github_io=self.webpackChunkneohaskell_github_io||[]).push([[1333],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),u=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(o.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),m=a,g=p["".concat(o,".").concat(m)]||p[m]||d[m]||s;return n?r.createElement(g,i(i({ref:t},c),{},{components:n})):r.createElement(g,i({ref:t},c))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[p]="string"==typeof e?e:a,i[1]=l;for(var u=2;u<s;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>i});var r=n(7294),a=n(6010);const s={tabItem:"tabItem_Ymn6"};function i(e){let{children:t,hidden:n,className:i}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(s.tabItem,i),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>S});var r=n(7462),a=n(7294),s=n(6010),i=n(2466),l=n(6550),o=n(1980),u=n(7392),c=n(12);function p(e){return function(e){return a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:a}}=e;return{value:t,label:n,attributes:r,default:a}}))}function d(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function g(e){let{queryString:t=!1,groupId:n}=e;const r=(0,l.k6)(),s=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,o._X)(s),(0,a.useCallback)((e=>{if(!s)return;const t=new URLSearchParams(r.location.search);t.set(s,e),r.replace({...r.location,search:t.toString()})}),[s,r])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,s=d(e),[i,l]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:s}))),[o,u]=g({queryString:n,groupId:r}),[p,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,s]=(0,c.Nk)(n);return[r,(0,a.useCallback)((e=>{n&&s.set(e)}),[n,s])]}({groupId:r}),h=(()=>{const e=o??p;return m({value:e,tabValues:s})?e:null})();(0,a.useLayoutEffect)((()=>{h&&l(h)}),[h]);return{selectedValue:i,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),f(e)}),[u,f,s]),tabValues:s}}var h=n(2389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:n,selectedValue:l,selectValue:o,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:p}=(0,i.o5)(),d=e=>{const t=e.currentTarget,n=c.indexOf(t),r=u[n].value;r!==l&&(p(t),o(r))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:i}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:d},i,{className:(0,s.Z)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":l===t})}),n??t)})))}function k(e){let{lazy:t,children:n,selectedValue:r}=e;const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=s.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},s.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function v(e){const t=f(e);return a.createElement("div",{className:(0,s.Z)("tabs-container",b.tabList)},a.createElement(y,(0,r.Z)({},e,t)),a.createElement(k,(0,r.Z)({},e,t)))}function S(e){const t=(0,h.Z)();return a.createElement(v,(0,r.Z)({key:String(t)},e))}},165:(e,t,n)=>{n.d(t,{Z:()=>a});var r=n(7294);const a=e=>{let{issue:t,absolute:n}=e;const[a,s]=r.useState("loading"),[i,l]=r.useState();(0,r.useEffect)((()=>{try{fetch(`https://api.github.com/repos/neohaskell/neohaskell/issues/${t}`).then((e=>e.json())).then((e=>{e&&(s(e.state),l(e.title))}))}catch(e){console.error(e)}}),[]);const o=a?`NOT IMPLEMENTED YET: #${t} - ${i}`:"LOADING",u=`tooltip ${n?"absolute z-10 p-4":""}`;return r.createElement("a",{className:u,"data-tip":o,target:"_blank",href:`https://github.com/neohaskell/neohaskell/issues/${t}`},r.createElement("div",{className:`badge border-black ${{open:"badge-warning",closed:"hidden",loading:"badge-primary"}[a]} badge-lg`}))}},1645:(e,t,n)=>{n.d(t,{Z:()=>a});var r=n(7294);function a(e){let{src:t,sourceLink:n,alt:a}=e;return r.createElement("figure",{className:"!flex !flex-col !place-items-center"},r.createElement("img",{src:t,alt:a}),r.createElement("figcaption",{className:"!text-xs"},`Source: ${n}`))}},1653:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>g,frontMatter:()=>l,metadata:()=>u,toc:()=>p});var r=n(7462),a=(n(7294),n(3905)),s=n(4866),i=n(5162);n(165),n(1645);const l={sidebar_position:8},o="Strings",u={unversionedId:"essentials/strings",id:"essentials/strings",title:"Strings",description:"The documentation that you're reading is a design document where most of",source:"@site/docs/essentials/strings.mdx",sourceDirName:"essentials",slug:"/essentials/strings",permalink:"/docs/essentials/strings",draft:!1,editUrl:"https://github.com/neohaskell/neohaskell.github.io/tree/main/docs/essentials/strings.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Pattern Matching",permalink:"/docs/essentials/pattern-matching"},next:{title:"Core Modules",permalink:"/docs/category/core-modules"}},c={},p=[{value:"Crafting and Utilizing Strings",id:"crafting-and-utilizing-strings",level:2},{value:"Purposeful Use of Strings",id:"purposeful-use-of-strings",level:2},{value:"Enums vs. Strings",id:"enums-vs-strings",level:2},{value:"Embracing Type Safety",id:"embracing-type-safety",level:2},{value:"String Operations",id:"string-operations",level:2},{value:"Interacting with Strings",id:"interacting-with-strings",level:2},{value:"Conclusion and Next Steps",id:"conclusion-and-next-steps",level:2}],d={toc:p},m="wrapper";function g(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"strings"},"Strings"),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"The documentation that you're reading is a design document where most of\nthe features you're reading are yet to be implemented. Check the ",(0,a.kt)("a",{parentName:"p",href:"/docs/docs-intro"},"Note on the Docs"))),(0,a.kt)("p",null,"NeoHaskell embraces strings as a versatile and indispensable part of programming, especially when dealing with data that is inherently variable and not known until runtime."),(0,a.kt)("h2",{id:"crafting-and-utilizing-strings"},"Crafting and Utilizing Strings"),(0,a.kt)("p",null,"Defining a string in NeoHaskell is as simple as in any language\u2014just a matter of enclosing your text within double quotes:"),(0,a.kt)(s.Z,{mdxType:"Tabs"},(0,a.kt)(i.Z,{value:"NeoHaskell",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},'greeting :: String\ngreeting = "Hello, NeoHaskell!"\n'))),(0,a.kt)(i.Z,{value:"TypeScript",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'let greeting: string = "Hello, TypeScript!";\n')))),(0,a.kt)("h2",{id:"purposeful-use-of-strings"},"Purposeful Use of Strings"),(0,a.kt)("p",null,"While strings are powerful, they should be used judiciously. In NeoHaskell, like in any language that supports strong typing, strings are ideal for representing text values that are inherently unpredictable or user-defined, such as names, email addresses, or free-form text input."),(0,a.kt)(s.Z,{mdxType:"Tabs"},(0,a.kt)(i.Z,{value:"NeoHaskell",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},'userName :: String\nuserName = "Jesse123"\n\nuserEmail :: String\nuserEmail = "jesse@example.com"\n'))),(0,a.kt)(i.Z,{value:"TypeScript",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'let userName: string = "Jesse123";\nlet userEmail: string = "jesse@example.com";\n')))),(0,a.kt)("h2",{id:"enums-vs-strings"},"Enums vs. Strings"),(0,a.kt)("p",null,"For values that are known and finite, enums are a more type-safe option than strings. Using enums can prevent errors like typos at compile time rather than at runtime, making your code more reliable and easier to maintain."),(0,a.kt)(s.Z,{mdxType:"Tabs"},(0,a.kt)(i.Z,{value:"NeoHaskell",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},'data UserRole\n  = Admin\n  | User\n  | Guest\n\n-- Correct use of enums for known, finite values\nassignRole :: String -> UserRole\nassignRole roleStr =\n  case roleStr of\n    "admin" ->\n      Admin\n\n    "user" ->\n      User\n\n    _ ->\n      Guest\n'))),(0,a.kt)(i.Z,{value:"TypeScript",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'enum UserRole {\n  Admin,\n  User,\n  Guest,\n}\n\n// Using enums in TypeScript to represent predefined roles\nfunction assignRole(roleStr: string): UserRole {\n  switch (roleStr) {\n    case "admin":\n      return UserRole.Admin;\n    case "user":\n      return UserRole.User;\n    default:\n      return UserRole.Guest;\n  }\n}\n')))),(0,a.kt)("h2",{id:"embracing-type-safety"},"Embracing Type Safety"),(0,a.kt)("p",null,"NeoHaskell encourages embracing type safety by using strings only when necessary and opting for enums or other more specific types when possible. This practice aids in avoiding common pitfalls associated with string manipulation, such as unexpected mutations or case sensitivity issues."),(0,a.kt)("h2",{id:"string-operations"},"String Operations"),(0,a.kt)("p",null,"NeoHaskell provides a comprehensive set of functions for string manipulation, allowing you to perform common operations such as concatenation, case conversion, and more, without the overhead of object-oriented methods."),(0,a.kt)(s.Z,{mdxType:"Tabs"},(0,a.kt)(i.Z,{value:"NeoHaskell",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},'import String\n\n-- Joining strings together\ncombinedString :: String\ncombinedString = String.concat ["Neo", "Haskell"]\n\n-- Changing to uppercase\nuppercaseString :: String\nuppercaseString = String.toUpper "NeoHaskell"\n\n-- Replacing text within a string\nreplacedText :: String\nreplacedText str = String.replace "Old" "Neo" "OldHaskell"\n'))),(0,a.kt)(i.Z,{value:"TypeScript",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'// Joining strings together\nlet combinedString = ["Type", "Script"].join("");\n\n// Changing to uppercase\nlet uppercaseString = "TypeScript".toUpperCase();\n\n// Replacing text within a string\nlet replacedText = "JavaScript".replace("Java", "Type");\n')))),(0,a.kt)("h2",{id:"interacting-with-strings"},"Interacting with Strings"),(0,a.kt)("p",null,"In NeoHaskell, strings are not merely static entities but dynamic constructs that can be inspected, dissected, and transformed, providing robust capabilities for developers to handle text data."),(0,a.kt)("h2",{id:"conclusion-and-next-steps"},"Conclusion and Next Steps"),(0,a.kt)("p",null,"Strings are a fundamental tool in your NeoHaskell toolkit, to be used when the situation demands flexibility and dynamism. As you grow in your NeoHaskell journey, understanding when to use strings and when to opt for more rigid types like enums will be key to writing clean, effective code."))}g.isMDXComponent=!0}}]);